# fio 执行结果参数解读

解决一下执行了半天 fio，出来一堆数据，但是看不懂这个事情。（解释源于 fio 官网，博主只是个搬运工）

建议将本文档直接拷贝到自己本地代码编辑器看，比较直观

**以一条执行结果为例，进行说明**

```shell
#################### this rule is : -bs=4k -rw=randwrite , now time is 2020-06-12 13:45:57 ####################      -------------->记录当前条fio命令，是第几遍执行、执行规则、开始执行时间
mabo: (g=0): rw=randwrite, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=4
...
fio-3.7
Starting 8 threads

mabo: (groupid=0, jobs=8): err= 0: pid=16696: Fri Jun 12 13:48:58 2020
  write: IOPS=12.5k, BW=48.7MiB/s (51.1MB/s)(8767MiB/180002msec)             --------------> 见第7
    slat (usec): min=2, max=15356, avg=12.24, stdev=22.33                    -------------->slat是提交延迟，见第4
    clat (usec): min=629, max=224640, avg=2549.24, stdev=6164.78             --------------> clat是完成延迟，见第5
     lat (usec): min=1091, max=224667, avg=2562.28, stdev=6165.28            --------------> lat是总延迟，见第6
    clat percentiles (usec):                                                 -------------->   报告完成延迟百分比   (usec是微秒, msec是毫秒)
     |  1.00th=[  1385],  5.00th=[  1467], 10.00th=[  1516], 20.00th=[  1582],
     | 30.00th=[  1647], 40.00th=[  1696], 50.00th=[  1745], 60.00th=[  1811],
     | 70.00th=[  1893], 80.00th=[  2024], 90.00th=[  2343], 95.00th=[  3392],     -------------->  1.00th=[  1385] 表示延迟低于1385微秒的占1%, 同理99.50th=[ 26870]表示延迟低于26870微秒的占99.5%
     | 99.00th=[ 19792], 99.50th=[ 26870], 99.90th=[114820], 99.95th=[135267],
     | 99.99th=[156238]
   bw (  KiB/s): min= 1688, max= 9344, per=12.50%, avg=6233.54, stdev=1530.10, samples=2880 -------------->  见第8
   iops        : min=  422, max= 2336, avg=1558.36, stdev=382.53, samples=2880 -------------->  见第9
  lat (usec)   : 750=0.01%, 1000=0.01%
  lat (msec)   : 2=78.30%, 4=17.23%, 10=1.86%, 20=1.63%, 50=0.69%
  lat (msec)   : 100=0.14%, 250=0.14%                                       -------------->   lat (nsec/usec/msec)三个，见第10
  cpu          : usr=1.66%, sys=4.95%, ctx=1994767, majf=0, minf=19 -------------->   cpu使用率(取的是平均值)，见第10
  IO depths    : 1=0.1%, 2=0.1%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%     -------------->  IO depths，见第12
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%    -------------->  IO submit，见第13
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%    -------------->  IO complete，像上面的IO submit一样，但是要填写。
     issued rwts: total=0,2244431,0,0 short=0,0,0,0 dropped=0,0,0,0  -------------->  IO  issued rwts，发出的读取/写入/修剪请求的数量，以及其中有多少个请求被缩短或丢弃。
     latency   : target=0, window=0, percentile=100.00%, depth=4  -------------->  IO latency，见第14

Run status group 0 (all jobs):
  WRITE: bw=48.7MiB/s (51.1MB/s), 48.7MiB/s-48.7MiB/s (51.1MB/s-51.1MB/s), io=8767MiB (9193MB), run=180002-180002msec --------------> bw和io，见第15和16

Disk stats (read/write):
  vdb: ios=44/2243065, merge=0/0, ticks=47/5660960, in_queue=5679213, util=100.00%  --------------> ios是所有组执行的I / O数，ticks是使磁盘忙碌的滴答声数量，in_queue是在磁盘队列中花费的总时间，util见第17
```

**更多参数解释**

> 1. slat_percentiles = bool
>    slat_percentiles = 布尔,报告提交延迟百分比。没有记录同步 ioengine 的提交延迟。

> 2. iops
>    收集 IOPS 数据。 如果所有单独的 IOPS 测量值均在平均值 IOPS 的指定限制内，则停止工作（例如，iops：2 表示所有单独 IOPS 值必须在平均值的 2 内，而 iops：0.2％意味着所有单独的 IOPS 值必须在 在平均 IOPS 的 0.2％以内终止工作）。

> 3. 1.00%=6112
>    原文：Completion latency percentiles can be a grouping of up to 20 sets, so for the terse output fio writes all of them. Each field will look like this: 1.00%=6112 which is the Xth percentile, and the usec latency associated with it.
>    翻译：完成等待时间百分位数最多可以是 20 个集合的分组，因此对于简洁的输出 fio 来说，所有这些均要写入。 每个字段如下所示：1.00％= 6112，这是第 X 个百分位数，以及与其相关的 usec 延迟。

> 4. slat
>    提交延迟（min 为最小值，max 为最大值，avg 为平均值，stdev 为标准偏差）。 这是提交 I / O 所花费的时间。 对于同步 I / O，由于板条实际上是完成延迟，因此不会显示该行（因为队列/完成是其中的一项操作）。 该值可以为纳秒，微秒或毫秒-fio 将选择最合适的基准并打印（在纳秒以上的示例中为最佳刻度）。 注意：在--minimum 模式下，延迟始终以微秒为单位表示。

> 5. clat
>    完成延迟。 与板条同名，表示从提交到完成 I / O 件的时间。 对于同步 I / O，clat 通常等于（或非常接近）0，因为从提交到完成的时间基本上只是 CPU 时间（I / O 已经完成，请参阅板条说明）。

> 6. lat
>    总延迟。 与 slat 和 clat 相同，这表示从 fio 创建 I / O 单元到完成 I / O 操作的时间。

> 7. write: IOPS=12.5k, BW=48.7MiB/s (51.1MB/s)(8767MiB/180002msec)
>    读/写/修剪，冒号前面的字符串显示统计信息所针对的 I / O 方向。，IOPS 是每秒执行的平均 I / O。BW 是平均带宽速率，显示为：2 格式幂的值（10 格式幂的值）。最后两个值显示：（以 2 格式的幂执行的总 I / O /该线程的运行时）。

> 8. bw
>    基于样本的带宽统计。 与 xlat 统计信息同名，但还包括采样数量（样本）以及该线程在其组中接收的总聚合带宽的近似百分比（每）。仅当该组中的线程位于同一磁盘上时，最后一个值才真正有用，因为它们随后将争夺磁盘访问权限。

> 9. iops
>    IOPS 统计基于样本。 与 bw 一样

> 10. lat (nsec/usec/msec)
>     I / O 完成延迟的分布。 这是从 I / O 离开 fio 到完成的时间。 与上面单独的读取/写入/修剪（指 write: IOPS=88, BW=623KiB/s (638kB/s)(30.4MiB/50032msec)）部分不同，
>     此处和其余部分中的数据适用于报告组的所有 I / O。 250 = 0.04％表示在不到 250us 的时间内完成了 0.04％的 I / O。 500 = 64.11％表示 64.11％的 I / O 需要 250 到 499us 才能完成。

> 11. cpu
>     CPU 使用率。 用户和系统时间，以及该线程经历的上下文切换次数，系统和用户时间的使用情况，最后是主要和次要页面错误的数量。
>     CPU 利用率数字是该报告组中作业的平均值，而上下文计数器和故障计数器则求和。

> 12. IO depths
>     I / O 深度在整个工作周期中的分布。 数字被划分为 2 的幂，每个条目覆盖从该值到小于下一个条目的深度的深度–例如，16 =覆盖从 16 到 31 的深度。
>     请注意，深度分布条目覆盖的范围可以是 与等效的提交/完整分发条目所涵盖的范围不同。

> 13. IO submit
>     一个提交调用中要提交多少 I / O。 每个条目表示该数量及以下，直到上一个条目为止-例如 16 = 100％表示每个提交调用我们提交 9 至 16 个 I / O。
>     请注意，提交分布条目所覆盖的范围可以与等效深度分布条目所覆盖的范围不同。

> 14. IO latency
>     这些值适用于 latency_target 和相关选项。 启用这些选项后，本节将介绍满足指定的延迟目标所需的 I / O 深度。列出每个客户之后，将打印组统计信息。 它们将如下所示：
>     运行状态组 0（所有作业）：
>     读取：bw = 20.9MiB / s（21.9MB / s），10.4MiB / s-10.8MiB / s（10.9MB / s-11.3MB / s），io = 64.0MiB（67.1MB），运行= 2973-3069msec
>     写：bw = 1231KiB / s（1261kB / s），616KiB / s-621KiB / s（630kB / s-636kB / s），io = 64.0MiB（67.1MB），运行= 52747-53223msec

> 15. WRITE:中的 bw
>     该组中线程的总带宽，然后是该组中所有线程的最小和最大带宽。 括号外的值是 2 的幂的格式，而括号内的值是 10 的幂的等效值。

> 16. WRITE:中的 io
>     该组中所有线程执行的聚合 I / O。 格式与 bw 相同。

> 17. util
>     磁盘利用率。 值为 100％表示我们使磁盘一直处于繁忙状态，而 50％的磁盘将有一半的时间处于空闲状态。
>     也有可能在运行时输出当前输出而不终止作业。 为此，请发送 USR1 信号。 您还可以通过使用--status-interval 参数或在/ tmp 中创建名为 fio-dump-status 的文件来获得定时定时转储。 如果 fio 看到此文件，它将取消链接并转储当前输出状态。

fio 官网链接：https://fio.readthedocs.io/en/latest/fio_doc.html
